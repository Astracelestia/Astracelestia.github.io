<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Voting Runner — Responsive</title>
<style>
html,body{
 width: 100vw;
 height: 100vh;
 margin: 0;
 overflow: hidden;
 font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
 background:url('background.png') no-repeat center center fixed;
 background-size: cover;
}
#wrap{
 position:relative;
 width:100vw;
 height:100vh;
 display:flex;
 align-items:center;
 justify-content:center;
 overflow:hidden;
}
canvas{
 display:block;
 border-radius:12px;
 box-shadow:0 10px 30px rgba(10,30,60,0.25);
}
#hudTop{
 position:absolute;
 top:20px; /* Disesuaikan agar terlihat rapi */
 left:50%;
 transform:translateX(-50%);
 z-index:20;
 text-align:center;
 pointer-events:none;
 background: rgba(255, 255, 255, 0.1);
 backdrop-filter: blur(8px);
 border: 1px solid rgba(255, 255, 255, 0.15);
 border-radius: 16px;
 padding: 12px 20px;
 box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
}
#score{
 color:#fff;
 font-weight:700;
 font-size:56px;
 text-shadow:0 0 8px rgba(255,255,255,0.6), 0 0 12px rgba(173,216,230,0.4);
}
#highscore{
 color:#e9f7ff;
 font-size:20px;
 margin-top:6px;
 text-shadow:0 0 6px rgba(255,255,255,0.5), 0 0 8px rgba(173,216,230,0.3);
}
#voteUI { display: none; }
.voteButtons{
 display:flex;
 gap:10px;
 flex:1;
 justify-content:space-around;
}
.voteBtn{
 flex:1;
 padding:12px 8px;
 border-radius:10px;
 text-align:center;
 cursor:pointer;
 user-select:none;
 background:linear-gradient(180deg,#ffffff11,#ffffff08);
 color:#fff;
 font-weight:700;
 font-size:18px;
 border:1px solid rgba(255,255,255,0.04);
 transition:transform .08s;
}
.voteBtn:active{
 transform:translateY(2px) scale(.995);
}
.progressRow{
 display:flex;
 gap:8px;
 margin-top:10px;
 align-items:center;
}
.label{
 width:56px;
 font-size:16px;
 font-weight:700;
 color:#e6f7ff;
 text-align:left;
}
.barWrap{
 flex:1;
 background:rgba(0,0,0,0.12);
 border-radius:8px;
 height:14px;
 overflow:hidden;
}
.bar{
 height:100%;
 background:linear-gradient(90deg,#21d4fd,#b721ff);
 width:0%;
 transition:width .2s linear;
}
#countdown{
 margin-left:12px;
 min-width:106px;
 text-align:right;
 color:#fff;
 font-weight:700;
}
#controls{
 position:absolute;
 top:20px;
 right:18px;
 z-index:21;
 display:flex;
 gap:8px;
}
.ctrlBtn{
 padding:8px 10px;
 border-radius:8px;
 background:#ffffff09;
 color:#fff;
 border:1px solid rgba(255,255,255,.05);
 cursor:pointer;
}
#debug{
 position:absolute;
 left:12px;
 bottom:12px;
 z-index:22;
 color:#0f0;
 font-family:monospace;
 font-size:12px;
 opacity:.95;
 display:none;
 background:rgba(0,0,0,0.45);
 padding:8px;
 border-radius:8px;
 max-width:320px;
 max-height:220px;
 overflow:auto;
}

.lane-labels {
 position: absolute;
 top: 170px;
 width: 80%;
 max-width: 900px;
 display: flex;
 justify-content: space-between;
 align-items: flex-start;
 z-index: 20;
 padding: 0 20px;
 left: 50%;
 transform: translateX(-50%);
 background: rgba(255, 255, 255, 0.1);
 backdrop-filter: blur(8px);
 border: 1px solid rgba(255, 255, 255, 0.15);
 border-radius: 16px;
 padding: 12px;
 box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
}

.lane-label-item {
 background: none;
 padding: 8px 16px;
 border-radius: 8px;
 backdrop-filter: none;
 color: #fff;
 font-weight: 700;
 font-size: 20px;
 text-align: center;
 text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);
 display: flex;
 flex-direction: column;
 align-items: center;
 gap: 8px;
}

.vote-counter {
 font-size: 36px;
 font-weight: 900;
 color: #fff;
 text-shadow: 0 0 10px #00e5ff, 0 0 20px #00e5ff, 0 0 30px #00e5ff;
 padding: 4px 8px;
 border-radius: 6px;
 background: rgba(255, 255, 255, 0.1);
}
</style>
</head>
<body>
<div id="wrap">
 
  <div class="lane-labels">
  <div class="lane-label-item">KIRI<span id="p-left" class="vote-counter">0</span></div>
  <div class="lane-label-item">TENGAH<span id="p-mid" class="vote-counter">0</span></div>
  <div class="lane-label-item">KANAN<span id="p-right" class="vote-counter">0</span></div>
 </div>
 
 <div id="hudTop"><div id="score">Score: 0</div><div id="highscore">Highscore: 0</div></div>

  <div id="voteUI" style="display: none;">
 <div class="voteCard">
  <div class="voteButtons">
  <div class="voteBtn" data-cmd="left">◀︎ LEFT</div>
  <div class="voteBtn" data-cmd="mid">● MID</div>
  <div class="voteBtn" data-cmd="right">RIGHT ▶︎</div>
  </div>
  <div id="countdown">15s</div>
 </div>

 <div class="voteCard" style="margin-top:10px;flex-direction:column;">
  <div class="progressRow"><div class="label">LEFT</div><div class="barWrap"><div id="bar-left" class="bar"></div></div><div id="p-left-old">0</div></div>
  <div class="progressRow"><div class="label">MID</div><div class="barWrap"><div id="bar-mid" class="bar"></div></div><div id="p-mid-old">0</div></div>
  <div class="progressRow"><div class="label">RIGHT</div><div class="barWrap"><div id="bar-right" class="bar"></div></div><div id="p-right-old">0</div></div>
 </div>
 </div>

 <div id="controls">
 <button class="ctrlBtn" id="toggleDebug">Debug</button>
 <button class="ctrlBtn" id="resetHS">Reset HS</button>
 </div>

 <div id="debug"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* ===== CONFIG ===== */
const CANVAS_W = window.innerWidth, CANVAS_H = window.innerHeight; // Mengambil ukuran jendela
const SPAWN_Z = -80, TARGET_Z = 0;
const VOTE_SECONDS = 15;
const MOVE_DURATION = 0.9;
const LANE_X = [-3, 0, 3];
const COLLISION_THRESHOLD = 1.2;
const MOVE_SAFETY_MARGIN = 0.12;
const PREDICTIVE_MOVE_DURATION = 0.3;
/* ================== */

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(CANVAS_W, CANVAS_H, false);
document.getElementById('wrap').appendChild(renderer.domElement);

const scene = new THREE.Scene();
const loader = new THREE.TextureLoader();

// Background optional
loader.load('background.png', texture => {
  scene.background = texture;
  animate();
}, undefined, err => {
  console.error('Gagal memuat tekstur background:', err);
  // biarkan scene.background tetap null (transparan)
  animate();
});

const camera = new THREE.PerspectiveCamera(25, CANVAS_W/CANVAS_H, 0.1, 1000);
camera.position.set(0, 2.5, 15);
camera.lookAt(0, 19.5, -300);

// Track
const trackTex = loader.load('jalan.png', t => { t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(1,40) }, undefined, ()=>{});
const trackMat = new THREE.MeshBasicMaterial({
  map: trackTex,
  transparent: true,
  alphaTest: 0.5,   // jika ada area transparan di jalan.png
  // depthWrite default true -> track menulis depth (bagus)
});
const trackMesh = new THREE.Mesh(new THREE.PlaneGeometry(12,400,1,1), trackMat);
trackMesh.rotation.x = -Math.PI/2;
trackMesh.position.y = 0;
trackMesh.renderOrder = 0;
scene.add(trackMesh);

/* load player-left and player-right textures with fallback canvas */
function genPlayerFallback(side){ const c=document.createElement('canvas'); c.width=256; c.height=256; const ctx=c.getContext('2d'); ctx.clearRect(0,0,256,256);
// body
ctx.fillStyle='#ff6b6b'; ctx.beginPath(); ctx.arc(128,112,90,0,Math.PI*2); ctx.fill();
// foot (left or right)
ctx.fillStyle='#3a3a3a'; if(side==='left'){ ctx.fillRect(58,160,40,18); } else { ctx.fillRect(158,160,40,18); }
ctx.fillStyle='#fff'; ctx.font='20px sans-serif'; ctx.textAlign='center'; ctx.fillText(side==='left'?'L':'R',128,132);
return new THREE.CanvasTexture(c);
}
let playerLeftTex=null, playerRightTex=null;
let playerSprite=null;
/* load textures */
loader.load('player-left.png', t=>{ playerLeftTex = t; checkCreatePlayer(); }, undefined, ()=>{ playerLeftTex = genPlayerFallback('left'); checkCreatePlayer(); });
loader.load('player-right.png', t=>{ playerRightTex = t; checkCreatePlayer(); }, undefined, ()=>{ playerRightTex = genPlayerFallback('right'); checkCreatePlayer(); });

function checkCreatePlayer(){
  if(!playerLeftTex || !playerRightTex) return;
  // SpriteMaterial dengan depthWrite:false supaya tidak memotong objek di belakang,
  // alphaTest untuk buang pixel semi-transparan, dan renderOrder agar selalu di-render setelah track.
  const mat = new THREE.SpriteMaterial({
    map: playerLeftTex,
    transparent: true,
    alphaTest: 0.5,
    depthWrite: false,    // jangan tulis ke depth buffer (menghindari "invisible box")
    depthTest: true
  });
  playerSprite = new THREE.Sprite(mat);
  playerSprite.scale.set(1.2,2,1);
  playerSprite.position.set(0, 1.4, TARGET_Z);
  playerSprite.renderOrder = 10; // render terakhir (di atas track & obstacle yang di-render sebelum)
  scene.add(playerSprite);
}

/* obstacles textures preload */
const OB = ['obstacle/obs1.png','obstacle/obs2.png','obstacle/obs3.png'];
const obsTex = [];
OB.forEach(p => loader.load(p, t=>obsTex.push(t), undefined, ()=>{}));

let obstacles = [];
let obstacleSpeed = Math.abs(SPAWN_Z - TARGET_Z) / VOTE_SECONDS;

/* UI references */
const scoreEl = document.getElementById('score');
const hsEl = document.getElementById('highscore');
const barLeft = document.getElementById('bar-left');
const barMid = document.getElementById('bar-mid');
const barRight = document.getElementById('bar-right');
const pLeft = document.getElementById('p-left');
const pMid = document.getElementById('p-mid');
const pRight = document.getElementById('p-right');
const countdownEl = document.getElementById('countdown');
const debugEl = document.getElementById('debug');

/* score */
let score = 0;
const APP_SCRIPT_URL = "https://script.google.com/macros/s/AKfycby_RvNgPP3jZeQ3dihxVX_OHuKPuQW7RNFmS2iyMZGWSxweP7wSp3hRCL7PtX4XWbmfWg/exec";
let highscore = 0;

function getHighscore() {
fetch(APP_SCRIPT_URL)
 .then(response => response.json())
 .then(data => {
 highscore = data.highscore;
 hsEl.innerText = `Highscore: ${highscore}`;
 dbg('Highscore berhasil diambil: ' + highscore);
 })
 .catch(error => {
 console.error('Gagal mengambil highscore:', error);
 dbg('ERROR: Gagal mengambil highscore.');
 });
}

function sendScoreToGoogleSheets(currentScore) {
const data = { score: currentScore };

fetch(APP_SCRIPT_URL, {
 method: 'POST',
 mode: 'no-cors',
 body: new URLSearchParams(data)
})
.then(response => {
 dbg('Skor dikirim. Memeriksa highscore terbaru...');
 getHighscore();
})
.catch(error => {
 console.error('Gagal mengirim skor:', error);
 dbg('ERROR: Gagal mengirim skor.');
});
}

function resetHighscore() {
if (confirm('Apakah Anda yakin ingin mereset highscore?')) {
 fetch(APP_SCRIPT_URL, {
  method: 'POST',
  body: new URLSearchParams({ score: 0 })
 })
 .then(() => {
  dbg('Highscore berhasil di-reset.');
  getHighscore();
 })
 .catch(error => console.error('Gagal mereset highscore:', error));
}
}

/* voting */
let votes = { left:0, mid:0, right:0 };
let voteActive = false;
let voteRemaining = 0;
let awaitingNext = false;
let finalDesiredLaneX = 0;
let currentDesiredLaneX = 0;
let moveStartX = 0;
let moveTimer = 0;
let predictiveMoveTimer = 0;

/* running-frame animation */
let runTick = 0;
let runFrame = 0;

/* timing handles */
let countdownIntervalId = null;
let scheduledMoveTimeout = null;

/* UI buttons to simulate votes */
document.querySelectorAll('.voteBtn').forEach(btn=>{
btn.addEventListener('click', ()=>{
 if(!voteActive) return;
 const c = btn.dataset.cmd;
 votes[c] = (votes[c]||0) + 1;
 updateVoteBars();
 
 predictiveMove();
});
});

document.getElementById('toggleDebug').addEventListener('click', ()=>{ debugEl.style.display = debugEl.style.display==='block'?'none':'block'; });
document.getElementById('resetHS').addEventListener('click', resetHighscore);

function dbg(msg){ const t=new Date().toLocaleTimeString(); debugEl.innerHTML += `[${t}] ${msg}<br>`; debugEl.scrollTop = debugEl.scrollHeight; }

function updateVoteBars(){
const total = Math.max(1, votes.left + votes.mid + votes.right);
const pl = Math.round((votes.left/total)*100), pm = Math.round((votes.mid/total)*100), pr = Math.round((votes.right/total)*100);
pLeft.innerText = votes.left; pMid.innerText = votes.mid; pRight.innerText = votes.right;
}

function predictiveMove() {
const winner = tallyWinner();
const nextLaneX = (winner === 'left') ? LANE_X[0] : (winner === 'right') ? LANE_X[2] : LANE_X[1];

if (nextLaneX !== currentDesiredLaneX) {
 currentDesiredLaneX = nextLaneX;
 moveStartX = playerSprite ? playerSprite.position.x : 0;
 predictiveMoveTimer = PREDICTIVE_MOVE_DURATION;
 dbg(`Prediksi: Bergerak ke ${winner.toUpperCase()}`);
}
}

function spawnObstacle(){
if(awaitingNext || obstacles.length>0) return;
awaitingNext = true;
if(countdownIntervalId){ clearInterval(countdownIntervalId); countdownIntervalId = null; }
if(scheduledMoveTimeout){ clearTimeout(scheduledMoveTimeout); scheduledMoveTimeout = null; }
let tex = null;
if(obsTex.length>0) tex = obsTex[Math.floor(Math.random()*obsTex.length)];
else {
 const c = document.createElement('canvas'); c.width=128; c.height=128; const ctx=c.getContext('2d');
 ctx.fillStyle='#ffbb33'; ctx.fillRect(0,0,128,128); ctx.fillStyle='#fff'; ctx.font='20px sans-serif'; ctx.textAlign='center'; ctx.fillText('OB',64,76);
 tex = new THREE.CanvasTexture(c);
}
// Obstacle material: pakai alphaTest supaya bagian transparan tidak menulis depth,
// namun bagian opaque tetap menulis depth sehingga bisa menutupi player jika posisinya di depan.
const mat = new THREE.SpriteMaterial({
  map: tex,
  transparent: true,
  alphaTest: 0.5,
  depthWrite: true,
  depthTest: true
});
const obs = new THREE.Sprite(mat);
const laneIndex = Math.floor(Math.random()*3);
obs.userData.lane = laneIndex;
obs.scale.set(1.6,1.6,1.6);
obs.position.set(LANE_X[laneIndex], 1.4, SPAWN_Z);
obs.renderOrder = 5; // di-render sebelum player (player renderOrder = 10)
scene.add(obs);
obstacles.push(obs);
votes = { left:0, mid:0, right:0 };
voteActive = true;
voteRemaining = VOTE_SECONDS;
updateVoteBars();
dbg(`Spawned obstacle at ${['LEFT','MID','RIGHT'][laneIndex]}. Vote started (${VOTE_SECONDS}s)`);
countdownEl.innerText = `${voteRemaining}s`;
countdownIntervalId = setInterval(()=>{
 voteRemaining--;
 countdownEl.innerText = `${voteRemaining}s`;
 if(voteRemaining <= 0){
 clearInterval(countdownIntervalId);
 countdownIntervalId = null;
 voteActive = false;
 dbg('Vote window closed (UI timer).');
 }
}, 1000);
const msUntilMoveStart = Math.max(0, (VOTE_SECONDS - MOVE_DURATION - MOVE_SAFETY_MARGIN) * 1000);
scheduledMoveTimeout = setTimeout(()=>{
 voteActive = false;
 const winner = tallyWinner();
 dbg(`Scheduled tally -> winner: ${winner}. Starting final move (${MOVE_DURATION}s).`);
 finalDesiredLaneX = (winner === 'left') ? LANE_X[0] : (winner === 'right') ? LANE_X[2] : LANE_X[1];
 moveStartX = playerSprite ? playerSprite.position.x : 0;
 moveTimer = MOVE_DURATION;
}, msUntilMoveStart);
}

function tallyWinner(){
let entries = Object.entries(votes).sort((a,b)=>b[1]-a[1]);
let maxVal = entries[0][1];
let ties = entries.filter(e=>e[1]===maxVal).map(e=>e[0]);
let winner = ties.length>1 ? (ties.includes('mid')?'mid': ties[Math.floor(Math.random()*ties.length)]) : entries[0][0];
return winner;
}

function handleArrival(obs){
const dx = Math.abs(obs.position.x - (playerSprite?playerSprite.position.x:0));
const collided = dx < COLLISION_THRESHOLD;
if(collided){
 dbg('💥 Collision! Reset score.');
 score = 0;
 if(playerSprite) playerSprite.position.set(0,1.4,TARGET_Z);
} else {
 dbg('✅ Avoided! +1 score.');
 score += 1;
 if(score > highscore){
 sendScoreToGoogleSheets(score);
 }
}
scoreEl.innerText = `Score: ${score}`;
scene.remove(obs);
obstacles = obstacles.filter(o=>o!==obs);
awaitingNext = false;
setTimeout(()=> spawnIfReady(), 1000 + Math.random()*600);
}

function spawnIfReady(){ if(!awaitingNext && obstacles.length===0) spawnObstacle(); }

const clock = new THREE.Clock();
function animate(){
requestAnimationFrame(animate);
const dt = clock.getDelta();
if(trackTex) trackTex.offset.y += dt * 0.55;
runTick += dt;
if(runTick > 0.18){
 runTick = 0; runFrame = 1-runFrame;
 if(playerSprite && playerLeftTex && playerRightTex){
   // ganti map tanpa merubah material props
   playerSprite.material.map = runFrame===0 ? playerLeftTex : playerRightTex;
   playerSprite.material.needsUpdate = true;
 }
}
if(predictiveMoveTimer > 0 && playerSprite){
 const t = (PREDICTIVE_MOVE_DURATION - predictiveMoveTimer) / PREDICTIVE_MOVE_DURATION;
 const ease = 1 - Math.pow(1 - t, 3);
 playerSprite.position.x = moveStartX + (currentDesiredLaneX - moveStartX) * ease;
 predictiveMoveTimer -= dt;
 if(predictiveMoveTimer <= 0){
 playerSprite.position.x = currentDesiredLaneX;
 predictiveMoveTimer = 0;
 }
}
if(moveTimer > 0 && playerSprite){
 const t = (MOVE_DURATION - moveTimer) / MOVE_DURATION;
 const ease = 1 - Math.pow(1 - t, 3);
 playerSprite.position.x = moveStartX + (finalDesiredLaneX - moveStartX) * ease;
 moveTimer -= dt;
 if(moveTimer <= 0){
 playerSprite.position.x = finalDesiredLaneX;
 moveTimer = 0;
 }
}
for(let i=obstacles.length-1;i>=0;i--){
 const o = obstacles[i];
 o.position.z += obstacleSpeed * dt;
 if(o.position.z >= TARGET_Z){
 handleArrival(o);
 }
}
renderer.render(scene, camera);
}

// Fungsi untuk menyesuaikan ukuran render dan kamera
function onWindowResize() {
const newWidth = window.innerWidth;
const newHeight = window.innerHeight;
renderer.setSize(newWidth, newHeight, false);
camera.aspect = newWidth / newHeight;
camera.updateProjectionMatrix();
}

window.addEventListener('resize', onWindowResize, false);

/* initial spawn */
setTimeout(()=> spawnIfReady(), 600);

/* keyboard shortcuts for dev (A = left, S = mid, D = right) */
window.addEventListener('keydown', (e)=>{
if(!voteActive) return;
if(e.key.toLowerCase()==='a'){ votes.left++; updateVoteBars(); predictiveMove(); }
if(e.key.toLowerCase()==='s'){ votes.mid++; updateVoteBars(); predictiveMove(); }
if(e.key.toLowerCase()==='d'){ votes.right++; updateVoteBars(); predictiveMove(); }
});

/* small note */
dbg('Ready. Place player-left.png & player-right.png in same folder, obstacle images in obstacle/*.png (optional). Vote starts when obstacle spawns. MOVE_DURATION=' + MOVE_DURATION + 's; safety margin=' + MOVE_SAFETY_MARGIN + 's.');

// Panggil fungsi ini untuk pertama kali
getHighscore();
</script>
</body>
</html>
